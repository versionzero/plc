== Introduction ==

The Project Language Compiler (or PLC, as we shall refer to it from here on 
in) is a basic "Project Language" compiler designed to meet the requirements
for CPSC4600 at the University of Lethbridge.

The current version of the compiler is written with out the aid of scanner or
parser generating tools; however, this may change in future versions, as the
project develops.

=== Scanning Phase (now outdated) ===

The current version of the compiler does not do much, other than scan an input 
stream, and output tokens as it seems them.  The output takes the following 
form:

 <filename.p>:<line#>[<column#>]: <TOKEN ID>: <token value>

For instance, the following code:

 begin
    const num = 10;
    integer x, y;
    proc max
    $ this is a comment!
    begin
       if x > y -> write x. [] ~(x > y) -> write y.
       fi
    end
 end. 

generates:

 ...
 plc:2[0]: BEGIN: begin
 plc:3[3]: CONST: const
 plc:3[2]: IDENTIFIER: num
 plc:3[9]: EQUAL: =
 plc:3[10]: INTEGER: 10
 plc:3[9]: SEMICOLON: ;
 plc:4[3]: INTEGER: integer
 plc:4[2]: IDENTIFIER: x
 plc:4[8]: COMMA: ,
 plc:4[5]: IDENTIFIER: y
 plc:4[7]: SEMICOLON: ;
 plc:5[3]: PROC: proc
 plc:5[1]: IDENTIFIER: max
 ...

as it's output.  Yup, that's about as special as it gets for now.

=== Parsing Phase ===

The compiler now includes a parser module.  This module uses the previously
created scanner module to syntactically analyze the input.  In this module
we attempt to validate the syntactic structure of the code, and to output
location information when a violation of the language is encountered.

Like the scanner phase, we have some phase specific output.  Unlike the 
previous phase, the project can be configured to suppress this debug output.
Disabled by default, the debug information can be enabled by suppling 
--enable-debug=true as a parameter to the configure script.  What this option
does is allow the code to spit out parse tree information.  So, while there
is no actual parse tree maintained in the application itself, it can be 
observed during runtime as the parser descends into the parse tree.

== How to build the PLC == 

To build the project, simply run:

 # ./configure
 # make -j
   
This will configure and build PLC.  Optionally, one can add the 
--enable-debug=true flag to the ./configure line: this will enable trace
information about the parsing state. The -j flag for make compiles multiple 
files in parallel (helpful if you have distcc, a dual-core or a dual-processor
machine). Like many GNU projects, you can installthe compiler locally, using 
the following:

 # make install

Alternatively, you can run it with no installation:

 # cd src
 # ./plc ../tests/everything.p

The above will run the PLC using everything.p as the input source file. Also 
in the tests directory are other test files.  One is called unknown.p, which 
has a syntax error in it.  This file demonstrates the error handling built in 
to the PLC.

== Design ==

The design of the PLC is derived from many sources.  The initial skeleton code
was based on a previous project for Bioinformatics.  This provided the code
for file-handling and command-line processing, as well as some error handling 
methods.  However, by the end of this project, most of this initial code will
have been dispensed with.  It was only used to speed up the process of codeing.

=== Scanner Phase ===

The error handling code, for instance, does not scale well, and will be 
replaced with a new system.  This new system will use C++ exceptions and
will allow a great deal of the error handling to be moved out of the logic
of the compiler.  This will simplify any future changes in the scanner as 
well as the compiler itself.  Also, it should improve readability, by removing
all the current checks.

The second phase of the project, once we start adding the parser, will bring 
a new top level control systems as well.  Currently, the symbol table, as well
as the scanner itself, is "owned" by the main function.  In the future, there
will be a top level compiler object, which will take ownership of the symbol
table, the scanner, as well as the parser.  This will be useful, as well, once
the code generation phase is upon us; then, it will also own a code generation
object.

=== Parser Phase ===

In this phase we have enhanced and, in some cases, simplified  the error 
handling.  This means that not only is the previous error information 
emitted, but information to help determine the type of error is also emitted.
Thus, for example, when we expect to see a semicolon (';') but instead receive
a comma (',') in the input, we can tell the user that a comma was seen in place
of a semicolon, on line n.  This will help the user in correcting their code,
versus only being told there is some syntax error on line n.

== Structure ==

=== Classes ===

Scanner Phase:

* scanner	       actual scanning mechanisms
* scanner_error	       used to represent errors specific to scanning 
** unknown_symbol      an error that can be encountered while scanning;
   		       namely, when we encounter a symbol we do not 
		       recognize
* symboltbl            symbol table used by the compiler
* token		       holds all the information about a single token

Parser Phase:

* parser	       new parser module to help with syntactic analysis
* setops 	       set operation helpers: most of this is syntactic
  		       sugar, meaning that it supplies, for instance, a
		       a plus ('+') operator to return a set union and 
		       a set of functions to make sets in-place from a set
		       of parameters (not necessarily unique)
* scanner	       actual scanning mechanisms
* symboltbl            symbol table used by the compiler
* token		       holds all the information about a single token

=== Files ===

Scanner Phase:

* src/error.{cc,h}     these files contain all the error handling and recovery
  		       code.  
* src/misc.{cc,h}      code that does not fit nicely in to any other place
  		       is kept here
* src/plc.{cc,h}       these contain the compiler's main entry point, as well
  		       as any globaly accessible structures
* src/scanner.{cc,h}   in here is all the code for scanning an input stream
  		       and converting character streams in to token streams
* src/symboltbl.{cc,h} an implementation of a symbol table
* src/token.{cc,h}     contains all the code related to tokens, all their
  		       unique IDs, as well as string representations of the
		       tokens themselves.

Parser Phase:

* src/error.{cc,h}     these files contain all the error handling and recovery
  		       code.  
* src/misc.h           code that does not fit nicely in to any other place
  		       is kept here
* src/parser.{cc,h}    these files contain the parser module
* src/plc.{cc,h}       these contain the compiler's main entry point, as well
  		       as any globaly accessible structures
* src/scanner.{cc,h}   in here is all the code for scanning an input stream
  		       and converting character streams in to token streams
* src/setops.{cc,h}    set operations and enhancement
* src/symboltbl.{cc,h} an implementation of a symbol table
* src/token.{cc,h}     contains all the code related to tokens, all their
  		       unique IDs, as well as string representations of the
		       tokens themselves.
